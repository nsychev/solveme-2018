# Непорядок: Write-up

В данном таске нужно лишь внимательно прочитать условие.

Заметим, что перед началом всего алгоритма `x` устанавливается равным ключу шифрования, 
а затем каждое следующее значение `x` зависит только от предыдущего.

Но после первого же шага в начальном блоке `x` принимает значение 0, 1 или 2 (так как 
берется по модулю 3). Это означает, что существуют лишь три последовательности «случайных»
перестановок блоков.

Получить их очень просто — при ключе 0 первое «случайное» число станет равно 2, при 1 — 1, при 0 — 2.

Переберем три варианта и получим флаг. Сделать это можно, к примеру, 
[такой программой](private/realization.py).

*Мораль*: генерировать псевдослучайные числа нужно правильно. Например, так:

```
x = key

...
    x = (11027 * x + 367367) % 386093
    j = x % i
    swap(s[i], s[j])
```

Хоть с длиной блока 4 это всё ещё не очень надежный алгоритм, но случайность сильно увеличивается, и трёх вариантов уже недостаточно.

В идеале нужно брать длинные ключи и инициализировать `x` для каждого блока независимо.

Флаг: **sto_is_secure_nobody_can_see_it**
